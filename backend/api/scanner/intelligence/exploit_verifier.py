"""
Exploit Verifier â€” Armora v2.

Implements a deterministic multi-signal classification algorithm to reduce
false positives between SQL Injection and RCE, especially for time-based payloads.
"""

import logging

logger = logging.getLogger(__name__)

# Context Markers
SQL_MARKERS = [
    "SELECT", "UNION", "AND", "OR", "SLEEP(", 
    "BENCHMARK(", "--", "/*"
]

OS_MARKERS = [
    ";", "&&", "|", "`", "$(", 
    "whoami", "id", "sleep", "cat", "/etc/passwd"
]

def verify_sqli(payload: str, response: dict, delay_detected: bool) -> tuple:
    """
    Score SQL Injection signals.
    Returns (score, evidence_list)
    """
    score = 0
    evidence = []
    
    # payload to upper for marker check
    payload_up = payload.upper()
    
    # 1. SQL syntax error detected
    # (Checking if signatures were already found by detector)
    if response.get("signatures_found"):
        score += 3
        evidence.append("SQL syntax error signature detected")
        
    # 2. SQL markers present in payload
    has_markers = any(m in payload_up for m in SQL_MARKERS)
    if delay_detected and has_markers:
        score += 2
        evidence.append("Time-delay confirmed with SQL markers in payload")
        
    # 3. Reflected SQL keyword
    body = response.get("body", "").upper()
    reflected = [m for m in SQL_MARKERS if m in body and m in payload_up]
    if reflected:
        score += 2
        evidence.append(f"Reflected SQL keywords: {', '.join(reflected)}")

    # Note: Boolean-based and UNION count variations would be passed 
    # via explicit flags if the detector supports them. 
    # For now, we use these primary signals.

    return score, evidence

def verify_rce(payload: str, response: dict, delay_detected: bool) -> tuple:
    """
    Score RCE signals.
    Returns (score, evidence_list)
    """
    score = 0
    evidence = []
    
    body = response.get("body", "")
    
    # 1. OS output patterns (id, whoami, /etc/passwd)
    os_patterns = {
        "uid=": "Linux id output detected",
        "root:x:0:0": "/etc/passwd content detected",
        "armora_rce_9z": "Canary echo detected",
        "[fonts]": "Windows win.ini header detected"
    }
    
    found_os = False
    for pat, desc in os_patterns.items():
        if pat in body:
            score += 5
            evidence.append(desc)
            found_os = True
            
    # 2. Command separator works (simplified check)
    # If the response contains the canary or specific OS output
    if found_os:
        score += 2
        evidence.append("Command separator validated via OS output")

    # 3. Time delay confirmed only
    if delay_detected and not found_os:
        score += 1
        evidence.append("Time-delay detected (insufficient alone for RCE)")
        
    return score, evidence

def classify_exploit(payload: str, response: dict, delay_detected: bool) -> dict:
    """
    Multi-signal classification decision tree.
    """
    payload_up = payload.upper()
    
    result = {
        "type": "Suspicious",
        "confidence": 40,
        "evidence": [],
        "risk_score": 50
    }
    
    # Check both SQL and RCE signals regardless of delay
    sql_score, sql_evidence = verify_sqli(payload, response, delay_detected)
    rce_score, rce_evidence = verify_rce(payload, response, delay_detected)
    
    if rce_score >= 6:
        result.update({
            "type": "Remote Code Execution",
            "confidence": min(95, 50 + (rce_score * 7)),
            "evidence": rce_evidence,
            "risk_score": 95
        })
    elif sql_score >= 5:
        result.update({
            "type": "SQL Injection",
            "confidence": min(95, 50 + (sql_score * 8)),
            "evidence": sql_evidence,
            "risk_score": 85
        })
    elif delay_detected:
        if any(m in payload_up for m in SQL_MARKERS):
            result.update({
                "type": "Suspicious Time-Based Behavior (SQL context)",
                "confidence": 40,
                "evidence": sql_evidence + ["Score below confirmation threshold"],
                "risk_score": 60
            })
        elif any(m.lower() in payload.lower() for m in OS_MARKERS):
            result.update({
                "type": "Suspicious Time-Based Behavior (RCE context)",
                "confidence": 40,
                "evidence": rce_evidence + ["OS output validation mandatory for RCE confirmation"],
                "risk_score": 65
            })
        else:
            result.update({
                "type": "Suspicious Time-Based Behavior",
                "confidence": 40,
                "evidence": ["Anomalous delay detected without clear context markers"],
                "risk_score": 50
            })
    elif sql_score >= 3: # Fallback for error-based SQLi
        result.update({
            "type": "SQL Injection",
            "confidence": min(95, 40 + (sql_score * 10)),
            "evidence": sql_evidence,
            "risk_score": 80
        })
            
    return result
