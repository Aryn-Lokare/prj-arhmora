"""
Unit Tests for AI Exploitability & Fix Prioritization Engine.

Tests verify:
  - SQL Injection ranks higher than Missing Headers
  - Login endpoint vulnerabilities score higher (sensitive route boost)
  - Attack chain boosts apply correctly
  - Priority scores are 0–100
  - Priority levels map correctly (Critical / High / Medium / Low)
  - `why_fix_first` is a non-empty string
  - Scan summary counts are accurate
  - Fix library returns effort and risk_reduction for all types
  - Empty input returns gracefully
"""

import sys
import os
import pytest

# Add backend root to sys.path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), ".."))

from api.ai_engine.exploitability_engine import ExploitabilityEngine
from api.ai_engine.fix_library import get_fix_data, get_all_types


# ---------------------------------------------------------------------------
# Fixtures
# ---------------------------------------------------------------------------

@pytest.fixture
def engine():
    return ExploitabilityEngine()


@pytest.fixture
def sql_injection_on_login():
    return {
        "type": "SQL Injection",
        "severity": "High",
        "affected_url": "http://testphp.vulnweb.com/login.php?username=x",
        "affected_endpoints": ["/login.php?username"],
        "endpoint_sensitivity": "public",
        "detection_method": "rule",
        "classification": "confirmed",
        "occurrences": 1,
        "owasp": "A03:2021-Injection",
        "remediation": "Use parameterized queries",
    }


@pytest.fixture
def missing_headers_static():
    return {
        "type": "Missing Headers",
        "severity": "Low",
        "affected_url": "http://testphp.vulnweb.com/about.php",
        "affected_endpoints": ["/about.php"],
        "endpoint_sensitivity": "public",
        "detection_method": "rule",
        "classification": "confirmed",
        "occurrences": 1,
        "owasp": "A05:2021-Security-Misconfiguration",
        "remediation": "Add security headers",
    }


@pytest.fixture
def xss_with_missing_csp():
    """Two vulns that trigger 'Account Takeover Chain'."""
    return [
        {
            "type": "XSS",
            "severity": "Medium",
            "affected_url": "http://example.com/comment.php?text=x",
            "affected_endpoints": ["/comment.php?text"],
            "endpoint_sensitivity": "public",
            "detection_method": "rule",
            "classification": "confirmed",
            "occurrences": 2,
            "owasp": "A03:2021-Injection",
            "remediation": "Sanitize output",
        },
        {
            "type": "Missing CSP",
            "severity": "Low",
            "affected_url": "http://example.com/",
            "affected_endpoints": ["/"],
            "endpoint_sensitivity": "public",
            "detection_method": "rule",
            "classification": "confirmed",
            "occurrences": 1,
            "owasp": "A05:2021-Security-Misconfiguration",
            "remediation": "Add CSP header",
        },
    ]


@pytest.fixture
def full_mixed_scan():
    return [
        {
            "type": "Auth Bypass",
            "severity": "High",
            "affected_url": "http://example.com/admin/",
            "affected_endpoints": ["/admin/"],
            "endpoint_sensitivity": "admin",
            "detection_method": "rule",
            "classification": "confirmed",
            "occurrences": 1,
            "owasp": "A01:2021-Broken-Access-Control",
        },
        {
            "type": "SQL Injection",
            "severity": "High",
            "affected_url": "http://example.com/login.php?user=x",
            "affected_endpoints": ["/login.php?user"],
            "endpoint_sensitivity": "public",
            "detection_method": "rule",
            "classification": "confirmed",
            "occurrences": 3,
            "owasp": "A03:2021-Injection",
        },
        {
            "type": "XSS",
            "severity": "Medium",
            "affected_url": "http://example.com/search.php?q=x",
            "affected_endpoints": ["/search.php?q"],
            "endpoint_sensitivity": "public",
            "detection_method": "ai",
            "classification": "likely",
            "occurrences": 1,
            "owasp": "A03:2021-Injection",
        },
        {
            "type": "Information Disclosure",
            "severity": "Low",
            "affected_url": "http://example.com/",
            "affected_endpoints": ["/"],
            "endpoint_sensitivity": "public",
            "detection_method": "rule",
            "classification": "confirmed",
            "occurrences": 1,
            "owasp": "A01:2021-Broken-Access-Control",
        },
        {
            "type": "Missing Headers",
            "severity": "Low",
            "affected_url": "http://example.com/about.php",
            "affected_endpoints": ["/about.php"],
            "endpoint_sensitivity": "public",
            "detection_method": "rule",
            "classification": "confirmed",
            "occurrences": 1,
            "owasp": "A05:2021-Security-Misconfiguration",
        },
    ]


# ---------------------------------------------------------------------------
# Core Scoring Tests
# ---------------------------------------------------------------------------

class TestExploitabilityEngine:

    def test_sql_injection_scores_higher_than_missing_headers(self, engine, sql_injection_on_login, missing_headers_static):
        """SQL Injection must rank higher than Missing Headers by priority score."""
        result = engine.analyze([sql_injection_on_login, missing_headers_static], "http://testphp.vulnweb.com")
        vulns = result["prioritized_vulnerabilities"]

        sql_score = next(v["priority_score"] for v in vulns if v["type"] == "SQL Injection")
        headers_score = next(v["priority_score"] for v in vulns if v["type"] == "Missing Headers")

        assert sql_score > headers_score, (
            f"SQL Injection ({sql_score}) should be higher than Missing Headers ({headers_score})"
        )

    def test_login_endpoint_boosts_score(self, engine, sql_injection_on_login, missing_headers_static):
        """A SQL Injection on a login route should score higher than one on a generic route."""
        login_vuln = sql_injection_on_login  # has 'login' in URL
        generic_vuln = {
            **sql_injection_on_login,
            "affected_url": "http://testphp.vulnweb.com/products.php?id=1",
            "affected_endpoints": ["/products.php?id"],
        }

        result_login = engine.analyze([login_vuln], "http://testphp.vulnweb.com")
        result_generic = engine.analyze([generic_vuln], "http://testphp.vulnweb.com")

        login_score = result_login["prioritized_vulnerabilities"][0]["priority_score"]
        generic_score = result_generic["prioritized_vulnerabilities"][0]["priority_score"]

        assert login_score >= generic_score, (
            f"Login endpoint ({login_score}) should score >= generic endpoint ({generic_score})"
        )

    def test_priority_scores_in_valid_range(self, engine, full_mixed_scan):
        """All priority scores must be 0–100."""
        result = engine.analyze(full_mixed_scan, "http://example.com")
        for v in result["prioritized_vulnerabilities"]:
            assert 0 <= v["priority_score"] <= 100, (
                f"{v['type']} has out-of-range score: {v['priority_score']}"
            )

    def test_priority_levels_mapped_correctly(self, engine, full_mixed_scan):
        """Priority levels must match the score thresholds."""
        result = engine.analyze(full_mixed_scan, "http://example.com")
        for v in result["prioritized_vulnerabilities"]:
            score = v["priority_score"]
            level = v["priority_level"]
            if score >= 80:
                assert level == "Critical"
            elif score >= 60:
                assert level == "High"
            elif score >= 40:
                assert level == "Medium"
            else:
                assert level == "Low"

    def test_vulnerabilities_sorted_by_score(self, engine, full_mixed_scan):
        """Output must be sorted highest priority_score first."""
        result = engine.analyze(full_mixed_scan, "http://example.com")
        scores = [v["priority_score"] for v in result["prioritized_vulnerabilities"]]
        assert scores == sorted(scores, reverse=True), "Vulnerabilities not sorted by priority_score desc"

    def test_why_fix_first_is_non_empty(self, engine, full_mixed_scan):
        """Every vulnerability should have a non-empty why_fix_first explanation."""
        result = engine.analyze(full_mixed_scan, "http://example.com")
        for v in result["prioritized_vulnerabilities"]:
            assert v["why_fix_first"], f"{v['type']} has empty why_fix_first"
            assert len(v["why_fix_first"]) > 10, f"{v['type']} has suspiciously short why_fix_first"

    def test_scan_summary_counts_correct(self, engine, full_mixed_scan):
        """scan_summary counts must match actual priority levels."""
        result = engine.analyze(full_mixed_scan, "http://example.com")
        summary = result["scan_summary"]
        vulns = result["prioritized_vulnerabilities"]

        assert summary["total_vulnerabilities"] == len(full_mixed_scan)
        assert summary["critical"] == sum(1 for v in vulns if v["priority_level"] == "Critical")
        assert summary["high"] == sum(1 for v in vulns if v["priority_level"] == "High")
        assert summary["medium"] == sum(1 for v in vulns if v["priority_level"] == "Medium")
        assert summary["low"] == sum(1 for v in vulns if v["priority_level"] == "Low")

    # -----------------------------------------------------------------------
    # Attack Chain Tests
    # -----------------------------------------------------------------------

    def test_attack_chain_boost_applied(self, engine, xss_with_missing_csp):
        """XSS + Missing CSP should trigger Account Takeover Chain boost."""
        result = engine.analyze(xss_with_missing_csp, "http://example.com")
        xss_vuln = next(v for v in result["prioritized_vulnerabilities"] if v["type"] == "XSS")

        assert "Account Takeover Chain" in xss_vuln.get("attack_chains_applied", []), (
            "Account Takeover Chain should be detected when XSS + Missing CSP are both present"
        )
        assert xss_vuln["chain_boost_applied"] > 0, "Chain boost should be > 0"

    def test_attack_chains_detected_in_summary(self, engine, xss_with_missing_csp):
        """attack_chains_detected should list triggered chains."""
        result = engine.analyze(xss_with_missing_csp, "http://example.com")
        assert "Account Takeover Chain" in result["attack_chains_detected"]

    def test_no_chain_boost_without_trigger(self, engine, missing_headers_static):
        """A single Missing Headers vuln should not trigger any chains."""
        result = engine.analyze([missing_headers_static], "http://example.com/about.php")
        vuln = result["prioritized_vulnerabilities"][0]
        assert vuln["chain_boost_applied"] == 0.0

    # -----------------------------------------------------------------------
    # Edge Cases
    # -----------------------------------------------------------------------

    def test_empty_input_returns_empty_result(self, engine):
        """Empty vulnerability list should return empty summary without crashing."""
        result = engine.analyze([], "http://example.com")
        assert result["scan_summary"]["total_vulnerabilities"] == 0
        assert result["prioritized_vulnerabilities"] == []
        assert result["attack_chains_detected"] == []

    def test_unknown_vuln_type_handled_gracefully(self, engine):
        """Unrecognized vulnerability types should use defaults without crashing."""
        vuln = {
            "type": "Some Exotic Zero-Day",
            "severity": "High",
            "affected_url": "http://example.com/exotic",
            "affected_endpoints": ["/exotic"],
            "endpoint_sensitivity": "public",
            "detection_method": "ai",
            "classification": "suspicious",
            "occurrences": 1,
        }
        result = engine.analyze([vuln], "http://example.com")
        assert len(result["prioritized_vulnerabilities"]) == 1
        assert 0 <= result["prioritized_vulnerabilities"][0]["priority_score"] <= 100


# ---------------------------------------------------------------------------
# Fix Library Tests
# ---------------------------------------------------------------------------

class TestFixLibrary:

    def test_fix_data_returned_for_sql_injection(self):
        data = get_fix_data("SQL Injection")
        assert "remediation_text" in data
        assert data["fix_effort"] in ("low", "medium", "high")
        assert isinstance(data["risk_reduction_percent"], int)
        assert data["risk_reduction_percent"] > 0

    def test_fix_data_for_all_known_types(self):
        """All types in the library should return complete fix data."""
        for vuln_type in get_all_types():
            data = get_fix_data(vuln_type)
            assert data["remediation_text"], f"{vuln_type}: empty remediation_text"
            assert data["fix_effort"] in ("low", "medium", "high"), f"{vuln_type}: invalid fix_effort"
            assert 0 < data["risk_reduction_percent"] <= 100, f"{vuln_type}: invalid risk_reduction_percent"

    def test_unknown_type_returns_default(self):
        data = get_fix_data("Totally Unknown Vulnerability Type XYZ")
        assert "remediation_text" in data
        assert data["fix_effort"] in ("low", "medium", "high")
        assert data["risk_reduction_percent"] > 0

    def test_sql_injection_risk_reduction_higher_than_missing_headers(self):
        """SQL Injection should have higher risk reduction than Missing Headers."""
        sql_data = get_fix_data("SQL Injection")
        headers_data = get_fix_data("Missing Headers")
        assert sql_data["risk_reduction_percent"] > headers_data["risk_reduction_percent"]


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
